# 12.6 Bonus 연결리스트
* 연결리스트에서 포인터를 사용하는 이유   
   1. 동적 할당 받아서 연결 리스트를 구현하니까   
   2. 포인터의 기능 중 하나인 외부에서도 이 변수를 사용할거니까!   
    
* 연결리스트 함수 중 일부에서 더블 포인터를 받는 이유   
   1. C에서는 매개변수가 스택에 복사되기 때문에 그냥 포인터로 전달하면 매개변수에 포인터 변수가 복사됨   
   2. 더블 포인터로 전달하면 \* 연산자로 
   3. 이중 포인터일 때 메인함수에 있는 포인터 변수와 연결할 수 있기 때문에   

# 11.25~27 Part1 단위 테스트로 디버깅 및 코딩 표준 고치기   
* memo    
  * ft_atoi - 19자리 이상 시 리턴 값 수정   
atoi에서 64비트 int보다 큰 값이 들어올 때   
양수기준으로 클 때는 -1 반환   
음수기준으로 더 큰 값이 들어올 때는 0 반환   
  * ft_strlact - 리턴 값 수정   
dstsize가 dst + src 크기보다 큰 경우 : 모두 잘 붙여지고 dst+src반환   
dstsize가 dst보다는 크지만 src까지 합 한 것보다 작은 경우 : 잘려서 붙여지고 dst+src반환   
dstsize가 dst보다도 작은 경우 : src반환 + dstsize   
세번째 경우 dst + src 에서 반환값을 빼면 dstsize에 추가해야할 값을 알 수 있다   
   
  * ft_strchr - 매개변수를 int로 받는 이유   
    *ft_strchr의 사례   
오버플로우가 생겨도 그냥 형 변환할 때 그 비트 패턴에 맞는에 맞는 걸 허용하는 함수임 아래 ft_isascii와는 조금 다름   
    *ft_isascii의 사례   
매개변수가 char일 때는 오버플로우 언더플오우 신경을 써야 하지만 int일 경우에는 신경을 쓸 필요가 없다(21억을 넘는 값이 들어와서 오버플로우가 나는 경우가 아니면)   

<pre>
<code>
int	ft_isascii(int c)
{
	if (c >= 0 && c <= 255)
	{
		return (1);
	}
	return (0);
}
</code>
</pre>
   
  * ft_memmove   
    * void 간접 참조 대입   
void 일때는 간접 참조로 대입을 못 한다   
    * malloc 없이 overlap 구현   
dst가 src보다 주소값이 클 때는 overlap이 되기 때문에 뒤에서 복사   
src가 dst보다 주소값이 클 때는 앞에서 복사   
   
  * ft_memcmp   
    * 바이트 값을 비교할 때 unsigned char를 사용해야 한다   
1바이트에 있는 값에서 서로 큰지 비교하는데 unsigned를 사용하지 않으면 음수가 되서    
return 값인 매개변수끼리 뺄셈이 잘못되어 버린다   
    * while 조건식과 ++ 연산 케이스 총 정리   

>	1. 올바른 경우

<pre>
<code>
    
// i가 n이 될 때 탈출을 한다
// while문 안에 있는 건 n - 1까지 비교만한다
// if문이 while문 ++ 연산 전에 있기 때문에 이게 가능하다
// 만약에 조건식에 *p1 == *p2 작성 시 ++ 연산 후에 있기 때문에
// 블록 밖에서 리턴하는 경우 n인 상태에서 계산함으로 오류가 된다
// i는 0인데 거기에서 n - 1을 더하는 경우와 n을 더 하는 경우를 생각하면 쉽다
	ft_memcmp("abcdefghij", "abcdefgxyz", 7));

	i = 0;
	while (i < n)
	{
		if (*p1 != *p2)
		{
			return (*p1 - *p2);
		}
		p1++;
		p2++;
		i++;
	}
	return (0);

</code>
</pre>

>	2. while 조건식에 ++연산을 하는 경우   

<pre>
<code>
// 이 경우 i, p1, p2는 i < n조건에 걸려서 나갈 때
// 이미 +1이 되서 나간다. 따라서 나갈 때 n + 1이 된 상태로 나간다
// 2번과 비교했을 때 2번보다도 1 증가되서 나감을 주의하기

 	i = 0;
	while (i++ < n && *p1++ == *p2++)
	{
	}
	return (p1 - p2);
</code>
</pre>
   
>	3. while 문 {} 안에서 ++연산을 하는 경우   

<pre>
<code>
// 이 경우 i, p1, p2는 i < n조건에 걸려서 나갈 때 
// while문 안에서 ++을 했기 때문에 이미 ++된 상태로 i == n이 된다
// p1, p2도 n번쨰에 해당하게 된다 배열을 비교할 때 offset으로 0부터 시작하기
//  때문에 이때 배열 기준으로 +1 된 상태이다(while문에서 for문보다 위험한 경우)
// i는 n이 되었고 p1, p2는 비교할 대상에서 1칸 앞으로 간 상태이다
// p1[n - 1], p2[n - 1]을 비교해야하는데 [n]일 때 비교하고 있다

	i = 0;
	while (i < n && *p1 == *p2)
	{
		i++;
		p1++;
		p2++;
	}
	return (p1 - p2);
 
//따라서 이 코드도 틀리다
//i == n이 되고 n - 1이어야 되서 안 된다

	i = 0;
	while (i++ < n && p1[i] == p2[i])
	{
	}
	return (p1[i] - p2[i]);
}
</code>
</pre>

>	4. 인덱스를 쓰는데 조건식에서 실수하는 경우   

<pre>
<code>
// 이 경우 &&이 걸려있기 떄문에 i가 첫번째 조건식에서
// 증가하고 p1[i] == p2[i]가 증가해있다
// 따라서 n = 7이고 6번째까지 문자가 같다고 했을 때
// 1번에 해당함에도 i가 6일 때 첫번째 조건은 통과하고
// 후치로 i는 7이되고 2번째 조건에서 7번쨰 문자열이 되기 때문에
// 조건식을 나가버린다. 1번에 해당함에도 i는 8이 아니라 7이 된다
// 즉 후치 수식은 평가 후에 인덱스가 증가한다는 점 명심하기

	while (i++ < n && p1[i] == p2[i])
	{
		i++;
	}
	return (p1[i] - p2[i]);

</code>
</pre>

* time      
23개 C라이브러리 함수 디버깅   

# 11.25(수) How to make Makefile   
* memo   
makefile 작성   
메이크파일에서 수를 선언해서 전제 조건에 변수를 사용할 때 1개씩 가져오는 것이 아니라 여러 개 한꺼번에 가져온다   
반면에 변수를 선언해서 타겟에 넣으면 변수에 있는 값들을 1개씩 넣어준다   
    
<pre>
<code>
$(OBJS) : $(SRCS)
$(CC) $(CFLAGS) -c $< -o $@ -MD
</code>
</pre>
   
* src  
메이크 파일에 대한 기본적인 설명 https://bowbowbow.tistory.com/12   
메이크 파일을 어떻게 사용할까? https://modoocode.com/311   
메이크 파일 기초 사용 법 https://www.joinc.co.kr/w/Site/C/Documents/minzkn_make
메이크 파일 확장자 규칙 https://mintnlatte.tistory.com/433

* time 3.00   
